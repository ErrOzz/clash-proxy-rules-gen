import os
import json
import yaml
import secrets
import random
import base64
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import x25519
from dotenv import load_dotenv

# Import our internal modules
from panel_api import get_panel_session, get_inbound_data, update_inbound
import sync_configs  # Trigger Gist update

# Load environment variables
load_dotenv()

INBOUND_ID = int(os.getenv("INBOUND_ID", 1))

# TODO: fix the key generation.
# There is a problem with key generation:
# no connection can be established with the keys generated by this code.

def generate_x25519_keys():
    """
    Generates a new pair of X25519 keys using 'cryptography' library.
    ENCODING FIX: Uses URL-Safe Base64 (replacing +/ with -_) to match Xray requirements.
    """
    # 1. Generate Private Key object
    private_key_obj = x25519.X25519PrivateKey.generate()
    
    # 2. Derive Public Key object
    public_key_obj = private_key_obj.public_key()
    
    # 3. Get raw bytes (32 bytes each)
    private_bytes = private_key_obj.private_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PrivateFormat.Raw,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    public_bytes = public_key_obj.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw
    )
    
    # 4. Encode to URL-SAFE Base64 and STRIP PADDING '='
    # This ensures characters are only [a-z, A-Z, 0-9, -, _]
    private_b64 = base64.urlsafe_b64encode(private_bytes).decode('utf-8').rstrip('=')
    public_b64 = base64.urlsafe_b64encode(public_bytes).decode('utf-8').rstrip('=')
    
    return private_b64, public_b64

def generate_short_ids(count=4):
    """
    Generates a list of random ShortIds.
    """
    return [secrets.token_hex(4) for _ in range(count)]

def load_rotation_domains():
    """
    Loads the list of domains from YAML file.
    """
    base_dir = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(base_dir, 'rotation_domains.yaml')
    
    if not os.path.exists(file_path):
        print("‚ùå rotation_domains.yaml not found!")
        return []
        
    with open(file_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def rotate():
    print("üîÑ Starting Reality rotation process...")

    # 1. Authenticate
    session = get_panel_session()
    if not session: return

    # 2. Get Current Inbound Data
    inbound = get_inbound_data(session)
    if not inbound: return
    
    print(f"‚ÑπÔ∏è Target Inbound: {inbound['remark']}")

    # 3. Parse current settings
    try:
        stream_settings = json.loads(inbound['streamSettings'])
        if stream_settings.get('security') != 'reality':
            print("‚ùå Error: Inbound is not using Reality security. Aborting.")
            return
            
        reality_settings = stream_settings.get('realitySettings', {})
        current_snis = reality_settings.get('serverNames', [''])
        current_main_sni = current_snis[0] if current_snis else ""
        
    except Exception as e:
        print(f"‚ùå Error parsing current settings: {e}")
        return

    # 4. Prepare New Settings
    
    # A. Pick new Domain
    domains = load_rotation_domains()
    if not domains:
        print("‚ùå No domains loaded. Aborting.")
        return
        
    # Simple filtering
    available_domains = [d for d in domains if d != current_main_sni]
    
    if not available_domains:
        print("‚ö†Ô∏è Only current domain available. Rotating keys only.")
        root_domain = current_main_sni or domains[0]
    else:
        root_domain = random.choice(available_domains)

    # B. Generate SNI List & Dest
    new_snis = [root_domain, f"www.{root_domain}"]
    new_dest = f"{root_domain}:443"

    # C. Generate New Keys (Cryptography + UrlSafe)
    new_private_key, new_public_key = generate_x25519_keys()
    
    # D. Generate New ShortIds
    new_short_ids = generate_short_ids(4)

    print(f"üÜï Selected Domain: {root_domain}")
    print(f"   Target (Dest): {new_dest}")
    print(f"   New Public Key: {new_public_key}")

    # 5. Modify Inbound Object
    
    reality_settings['serverNames'] = new_snis
    reality_settings['shortIds'] = new_short_ids
    
    # Set 'target' explicitly (MHSanaei specific field for Dest)
    reality_settings['target'] = new_dest
    
    # Update Keys
    if 'settings' not in reality_settings:
        reality_settings['settings'] = {}
        
    reality_settings['settings']['publicKey'] = new_public_key
    reality_settings['settings']['privateKey'] = new_private_key
    
    # Pack back
    stream_settings['realitySettings'] = reality_settings
    inbound['streamSettings'] = json.dumps(stream_settings)

    # 6. Send Update
    print("‚è≥ Updating panel settings...")
    success = update_inbound(session, INBOUND_ID, inbound)
    
    if success:
        print("‚úÖ Rotation successful!")
        print("üöÄ Triggering config sync...")
        sync_configs.main()
    else:
        print("‚ùå Rotation failed.")

if __name__ == "__main__":
    rotate()